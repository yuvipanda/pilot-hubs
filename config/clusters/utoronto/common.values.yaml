nfs:
  enabled: true
  pv:
    # Recommended options from the Azure Portal UI for mounting the share
    mountOptions:
      - vers=4
      - minorversion=1
      - sec=sys
    serverIP: 2i2cutorontohubstorage.file.core.windows.net
    # Trailing slash is important!
    baseShareName: /2i2cutorontohubstorage/homes/
jupyterhub:
  scheduling:
    userScheduler:
      enabled: true
  # pre-puller is necessary as the image is pretty big, and
  # pulling during first user spawn might cause timeouts and poor user
  # experience. Also helps with node pre-warming.
  prePuller:
    continuous:
      enabled: true
    hook:
      enabled: true
  custom:
    homepage:
      templateVars:
        interface_selector: true
        org:
          name: University of Toronto
          logo_url: https://raw.githubusercontent.com/utoronto-2i2c/homepage/master/extra-assets/images/home-hero.png
          url: https://www.utoronto.ca/
        designed_by:
          name: 2i2c
          url: https://2i2c.org
        operated_by:
          name: 2i2c
          url: https://2i2c.org
        funded_by:
          name: University of Toronto
          url: https://www.utoronto.ca/
        announcements:
          - |
            <div>
              <h4>* NEW * Jupyter Support Website</h4>

              We have started a JupyterHub support website with documentation and tip sheets, and we will be adding more on an
              ongoing basis. To reach the support site, please visit: <a href="https://act.utoronto.ca/jupyterhub-support">https://act.utoronto.ca/jupyterhub-support/</a>.
            </div>
  singleuser:
    cpu:
      # Each node has about 8 CPUs total, and if we limit users to no more than
      # 4, no single user can take down a full node by themselves. We have to
      # set the guarantee to *something*, otherwise it is set to be equal
      # to the limit!
      limit: 4
      guarantee: 0.01
    memory:
      limit: 2G
      guarantee: 1G
    extraFiles:
      github-app-private-key.pem:
        mountPath: /etc/github/github-app-private-key.pem
        # stringData field will be set via encrypted values files but added here
        # to meet the chart schema validation requirements without the need to
        # use secret values during the validation.
        stringData: "dummy"
      gitconfig:
        mountPath: /etc/gitconfig
        # app-id comes from https://github.com/organizations/utoronto-2i2c/settings/apps/utoronto-jupyterhub-private-cloner
        stringData: |
          [credential "https://github.com"]
          helper = !git-credential-github-app --app-key-file /etc/github/github-app-private-key.pem --app-id 93515
          useHttpPath = true
  hub:
    db:
      pvc:
        # Default seems too slow for our database, causes very bad response times
        storageClassName: managed-premium
    readinessProbe:
      enabled: false
    extraConfig:
      11-fix-auth: |
        from oauthenticator.azuread import AzureAdOAuthenticator
        from tornado.httpclient import AsyncHTTPClient, HTTPClientError
        import json
        from urllib.parse import quote, urlparse, urlunparse

        from tornado.log import app_log

        class PatchedOAuthenticator(AzureAdOAuthenticator):
          async def fetch(self, req, label="fetching", parse_json=True, **kwargs):
            try:
                resp = await self.http_client.fetch(req, **kwargs)
            except HTTPClientError as e:
                if e.response:
                    print(e.response.headers, flush=True)
                    print(e.__dict__, flush=True)
                    # Log failed response message for debugging purposes
                    message = e.response.body.decode("utf8", "replace")
                    try:
                        # guess json, reformat for readability
                        json_message = json.loads(message)
                    except ValueError:
                        # not json
                        pass
                    else:
                        # reformat json log message for readability
                        message = json.dumps(json_message, sort_keys=True, indent=1)
                else:
                    # didn't get a response, e.g. connection error
                    message = str(e)

                # log url without query params
                url = urlunparse(urlparse(req.url)._replace(query=""))
                app_log.error(f"Error {label} {e.code} {req.method} {url}: {message}")
                raise e
            else:
                if parse_json:
                    if resp.body:
                        return json.loads(resp.body.decode('utf8', 'replace'))
                    else:
                        # empty body is None
                        return None
                else:
                    return resp

        c.JupyterHub.authenticator_class = PatchedOAuthenticator
    config:
      Authenticator:
        enable_auth_state: false
      JupyterHub:
        # authenticator_class: azuread
        concurrent_spawn_limit: 100
        # We wanna keep logs long term, primarily for analytics
        extra_log_file: /srv/jupyterhub/jupyterhub.log
      AzureAdOAuthenticator:
        username_claim: email
        login_service: "University of Toronto ID"
        tenant_id: 78aac226-2f03-4b4d-9037-b46d56c55210
        scopes:
          # To help offset some potential AzureAD weird errors
          # https://discourse.jupyter.org/t/problem-logging-in-to-azure-ad-with-mfa-enabled/12488/5?u=yuvipanda
          - openid
          - email
